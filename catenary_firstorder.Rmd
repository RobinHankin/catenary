---
title: "Perturbing the catenary: a first-order analysis"
author: "Robin Hankin"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## The catenary.

\newcommand{\di}[2]{\frac{\partial{#1}}{\partial{#2}}}
\newcommand{\cx}{\cosh{\left(\frac{x-x_0}{a}\right)}}
\newcommand{\sx}{\sinh{\left(\frac{x-x_0}{a}\right)}}
\newcommand{\tx}{\tanh{\left(\frac{x-x_0}{a}\right)}}
\newcommand{\sech}{\operatorname{sech}}

We start with functional $F = \sqrt{1+y'^2}(y+\lambda)$ and
Euler-Lagrange equation

\begin{equation}
\frac{d}{dx}\di{F}{y'} -\di{F}{y}=0
\end{equation}

We have $\di{F}{y'} = \frac{y'(y+\lambda)}{\sqrt{1+y'^2}}$ and 
$\di{F}{y} = \sqrt{1+y'^2}$ so

\begin{equation}
\frac{d}{dx}\left[\frac{y'(y+\lambda)}{\sqrt{1+y'^2}}\right] = \sqrt{1+y'^2}
\end{equation}

This gives $y = \operatorname{cosh} x$.

\begin{equation}
\frac{d}{dx}\di{F}{y'} -\di{F}{y}=0
\end{equation}


# Perturbing the catenary.

We now consider $Y=Y(x) = y(x) + \epsilon z(x)$, a slightly perturbed
solution to the EL equations above.  The first-order corrective term
gives functional

\begin{equation}
\overline{F} = \sqrt{1+Y'^2}(Y + \Lambda + \epsilon\phi(x,Y))
\end{equation}

where $\epsilon$ is small. EL becomes:


\begin{equation}
\frac{d}{dx}\di{\overline{F}}{Y'} -\di{\overline{F}}{Y}=0
\end{equation}

And we have

\begin{equation}
\di{\overline{F}}{Y'}
= \frac{Y'}{\sqrt{1+Y'^2}}(Y + \Lambda + \epsilon\phi(x,y))\qquad
\di{\overline{F}}{Y} = {\sqrt{1+Y'^2}}(1 + \epsilon_y\phi(x,y))
\end{equation}

Thus (working to first order)

\begin{eqnarray}
\frac{d}{dx}\left[\di{\overline{F}}{Y'}\right]
&=& \frac{d}{dt}\left[\frac{Y'}{\sqrt{1+Y'^2}}(Y + \Lambda + \epsilon\phi(x,Y))\right]\\
&=& \frac{Y''}{(1+Y'^2)^{3/2}}(Y + \Lambda + \epsilon\phi(x,Y)) + 
        \frac{Y'}{\sqrt{1+Y'^2}}(1 + \Lambda + \epsilon\phi_y(x,Y))\\
&=& \frac{y'' + \epsilon z''}{(1+(y'+\epsilon z')^2)^{3/2}}(y(x) + \epsilon z + \Lambda + \epsilon\phi) + 
        \frac{y'}{\sqrt{1+(y+\epsilon z')^2}}(1 + \Lambda + \epsilon\phi_y)\\
&=& \left(\frac{y''}{(1+(y'+\epsilon z')^2)^{3/2}} + 
\frac{\epsilon z''}{(1+(y'+\epsilon z')^2)^{3/2}}\right)(y(x) + \epsilon z + \Lambda + \epsilon\phi)\\
&{}& \qquad + \frac{y'}{\sqrt{1+(y+\epsilon z')^2}}(1 + \Lambda + \epsilon\phi_y)\\
&=& \left(\frac{y''}{(1+(y'+\epsilon z')^2)^{3/2}} + 
\frac{\epsilon z''}{(1+y'^2)^{3/2}}\right)(y(x) + \epsilon z + \Lambda + \epsilon\phi)\\
  &{}&   \qquad+ \frac{y'}{\sqrt{1+(y+\epsilon z')^2}}(1 + \Lambda + \epsilon\phi_y)\\
&=& \left(\frac{y''}{(1+y'^2)^{3/2}} - 3\epsilon\frac{z'y'}{(1+y'^2)^{5/2}}
 + \frac{\epsilon z''}{(1+y'^2)^{3/2}}\right)(y(x) + \epsilon z + \Lambda + \epsilon\phi)\\
  &{}&   \qquad+ \frac{y'}{\sqrt{1+(y'+\epsilon z')^2}}(1 + \Lambda + \epsilon\phi_y)\\
&=& \left(\frac{y''}{(1+y'^2)^{3/2}} - 3\epsilon\frac{z'y'}{(1+y'^2)^{5/2}}
 + \frac{\epsilon z''}{(1+y'^2)^{3/2}}\right)(y(x) + \epsilon z + \Lambda + \epsilon\phi)\\
  &{}&   \qquad + \left(\frac{y'}{\sqrt{1+y'^2}} + \epsilon\frac{z'}{(1+y'^2)^{3/2}}\right)
  (1 + \Lambda + \epsilon\phi_y)\\
&=& \left(\frac{y''}{(1+y'^2)^{3/2}} - 3\epsilon\frac{z'y'}{(1+y'^2)^{5/2}}
 + \frac{\epsilon z''}{(1+y'^2)^{3/2}}\right)(y(x) + \epsilon z + \Lambda + \epsilon\phi)\\
  &{}&   \qquad + \frac{y'(1+\Lambda)}{\sqrt{1+y'^2}} + \epsilon\left(\frac{z'(1+\Lambda)}{(1+y'^2)^{3/2}} +
  \frac{\phi_yy'}{\sqrt{1+y'^2}}\right)\\
&=& \frac{y''(y+\Lambda)}{(1+y'^2)^{3/2}} - 3\epsilon\frac{z'y'(y+\Lambda)}{(1+y'^2)^{5/2}}
 + \frac{\epsilon z''(y+\Lambda)}{(1+y'^2)^{3/2}} + \epsilon\frac{y''(z+\phi)}{(1+y'^2)^{3/2}}\\
&{}&   \qquad + \frac{y'(1+\Lambda)}{\sqrt{1+y'^2}} + \epsilon\left(\frac{z'(1+\Lambda)}{(1+y'^2)^{3/2}} +
  \frac{\phi_yy'}{\sqrt{1+y'^2}}\right)\\
&=& \frac{y''(y+\Lambda)}{(1+y'^2)^{3/2}} +  \frac{y'(1+\Lambda)}{\sqrt{1+y'^2}} \\
&{}& \qquad + \epsilon\left(
   - 3\frac{z'y'(y+\Lambda)}{(1+y'^2)^{5/2}}
  + \frac{z''(y+\Lambda)}{(1+y'^2)^{3/2}} + \frac{y''(z+\phi)}{(1+y'^2)^{3/2}}
  + \frac{z'(1+\Lambda)}{(1+y'^2)^{3/2}}
  +  \frac{\phi_yy'}{\sqrt{1+y'^2}}
  \right)\\
\end{eqnarray}

where $\phi=\phi(x,y)$, $z=z(x)$ and $z'=z'(x)$.






# Numerical work


```{r odesolver}
library("deSolve") 
sech <- function(x){1/cosh(x)}
Lorenz <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {
        dZ <- Zdash

        phi <- 10
        phi_y  <- 0
        phi_x <- 0
        numerator <- (
            +Zdash * (3*lambda * sech(t)^3 * tanh(t) + 2*sech(t)^2 * tanh(t))
            -Z     * sech(t)^2
            + phi_y * cosh(t)
            -(phi_x + phi_y*sinh(t))*tanh(t)
            -phi*sech(t)^2
        )

        denominator <- lambda *sech(t)^3  + sech(t)^2

        dZdash <- numerator/denominator
        dextra_length <- Zdash*tanh(t)
        dextra_length2 <- -Z*sech(t)^2
        list(c(dZ, dZdash, dextra_length, dextra_length2))
    })
}

parameters <- c(lambda = 0)
state      <- c(Z = 0, Zdash = 0, extra_length = 0, extra_length2 = 0)  # initial conditions
times      <- seq(-2, 2, by = 0.05)

out <- ode(y = state, times = times, func = Lorenz, parms = parameters)
```

```{r showode}
head(out)
tail(out)
x <- out[,1]
y <- out[,2]
plot(x,y,type='l')
grid()
```


```{r defodefunc}
f <- function(unknown, give=FALSE){
    lambda        <- unknown[1]
    Zdash_initial <- unknown[2]
    times <- seq(from = -2, to = 2, by = 1)
    parameters <- c(lambda = lambda)
    state <-  # initial conditions
        c(Z = 0, Zdash = Zdash_initial, extra_length=0, extra_length2=0) 
    out <- ode(y = state, times = times, func = Lorenz, parms = parameters)
    final_disp <- out[5,2]
    extra_length <- out[5,4]
    badness <- final_disp^2 + extra_length^2
    if(give){
        return(out)
    } else {
        return(badness)
    } 
}
```

```{r}
f(c(2, 1.0))
f(c(2, 1.1))
```
   
   
```{r cache=TRUE}
jj <- optim(c(0,0),f)
jj

```

```{r usef, cache=TRUE}
v1 <- seq(from = 0, to = 3, by = 1)
v2 <- seq(from = -5, to = -2, by = 1)
M <- as.matrix(expand.grid(v1,v2))
head(M)
bad <- sapply(seq_len(nrow(M)),function(i){f(unname(M[i,]))})
```

```{r contbad}
M <- matrix(bad,length(v1),length(v2))
contour(v1, v2, M, levels=0:10)
filled.contour(M)
```

next chunk

	
```{r}
jj$par
parameters <- c(lambda = jj$par[1])
state      <- c(Z = 0, Zdash = jj$par[2], extra_length=0, extra_length2=0)  # initial conditions
times      <- seq(-2, 2, by = 0.01)

out <- ode(y = state, times = times, func = Lorenz, parms = parameters)
head(out)
tail(out)
x  <- out[,1]
z <- out[,2]
y0 <- cosh(x)

plot(x, z,type="l")
plot(x, y0,type="l")
points(x, y0+z/10,type="l",col="red")
```


OK we have two points that are not the same but both satisfy the
boundary conditions and indeed the length constraint.
n


```{r}
p1 <- c(4,-3.409)
p2 <- c(3,-3.999)
```

```{r}
show <- function(p){
    parameters <- c(lambda = p[1])
state      <- c(Z = 0, Zdash = p[2], extra_length=0, extra_length2=0)  # initial conditions
times      <- seq(-2, 2, by = 0.01)
ode(y = state, times = times, func = Lorenz, parms = parameters)
}


jj1 <- show(p1)
jj2 <- show(p2)

plot(times,jj2[,2])
points(times,jj1[,2])


plot(times,jj1[,2]/jj2[,2])
```


```{r}
jj3 <- show(c(0, -8.7563))
plot(times,jj3[,2])
```

```{r}
parameters <- c(lambda = 0)
state      <- c(Z = 0, Zdash = -8.7563, extra_length=0, extra_length2=0)  # initial conditions
times      <- seq(-2, 2, by = 0.01)

out <- ode(y = state, times = times, func = Lorenz, parms = parameters)
head(out)
tail(out)
x  <- out[,1]
z <- out[,2]
y0 <- cosh(x)

plot(x, z,type="l")
plot(x, y0,type="l")
points(x, y0+z/5,type="l",col="red")
```
